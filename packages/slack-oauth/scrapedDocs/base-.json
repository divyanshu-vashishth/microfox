{
  "url": "https://api.slack.com/authentication/oauth-v2",
  "content": "Docs\nTutorials\nDeveloper Program\nYour apps\nSlack Platform\nSamples & templates\nDeveloper sandboxes\nSlack apps\nQuickstart: Send a message\nAuthentication\nOverview\nInstalling with OAuth\nToken rotation\nVerifying requests\nSecurity best practices\nAuthorize with Postman\nSign in with Slack\nSign in with Slack setup\nSign in with Slack links\nSign in with Slack links using Auth0\nLegacy app migration\nDifferences between classic apps and Slack apps\nMigration guide\nAI Apps\nOverview\nCustomizing Agentforce agents with custom Slack actions\nDeveloping AI apps in Slack\nAI apps best practices\nData Access API\nMessaging\nSend or schedule a message\nRetrieve a message\nEdit or delete a message\nMessage composition\nAdd interactivity\nWorking with files\nWorking with metadata\nOverview\nDesigning metadata schema\nMetadata events\nUsing incoming webhooks\nUnfurling links in messages\nUpgrading to blocks\nInteractivity\nHandling user interaction\nShortcuts\nSlash commands\nApp distribution\nDistributing Slack apps\nHosting Slack apps\nOnboarding users\nSlack Marketplace\nOverview\nSlack Marketplace review guide\nSlack Marketplace guidelines\nUsing Slack Marketplace\nSlack Marketplace checklist\nApps for Admins\nOverview\nWorkspace management\nManaging users\nManaging channels\nManaging app approvals\nManaging workflow permissions and approvals\nManging invite requests\nLegal Holds API\nOverview\nReference\nAudit Logs API\nMonitoring audit events\nMonitoring anomaly events\nEndpoints and actions\nSCIM API\nProvisioning with SCIM\nProvisioning with SCIM 2.0\nLegacy\nOverview\nLegacy authentication\nLegacy: V1 OAuth 2.0\nLegacy: OAuth Scopes\nLegacy: Sign in with Slack\nLegacy messaging\nLegacy: Messaging overview\nLegacy: interactive messages\nLegacy: Interactive field guide\nLegacy: Message buttons\nLegacy: Message menus\nLegacy: Secondary attachments\nLegacy bots\nLegacy dialogs\nLegacy custom integrations\nLegacy custom integrations migration\nLegacy custom integrations bot users\nLegacy custom integrations incoming webhooks\nLegacy custom integrations outgoing webhooks\nLegacy custom integations slash commands\nLegacy custom integrations tokens\nLegacy Steps from Apps\nLegacy Steps from Apps FAQ\nLegacy Steps from Apps migration guide\nLegacy RTM API\nPlatform concepts\nAPIs\nOverview\nWeb API\nOverview\nPagination\nRate limits\nConversations API\nCalls API\nPresence & status\nEvents API\nEvents API\nHTTP vs Socket Mode\nHTTP Request URLs\nSocket Mode\nSlack Connect\nUnderstanding Slack Connect\nUsing Slack Connect API methods\nSlack Connect API reference\nSlack Status API\nApp design\nApp manifests\nBlock Kit\nOverview\nBuilding with Block Kit\nDesigning with Block Kit\nBlock Kit Builder\nReference\nOverview\nBlocks\nBlock elements & interactive components\nComposition objects\nBlock actions payloads\nBlock suggestion payloads\nFormatting rich text\nBolt Frameworks\nOverview\nBolt for Java ↗\nBolt for JavaScript ↗\nBolt for Python ↗\nEnterprise Grid\nOverview\nSingle-workspace apps\nOrganization-ready apps\nMigrating to organization-ready apps\nTesting Enterprise Grid apps\nInvocation & interactivity\nSurfaces\nOverview\nMessages\nModals\nApp Home\nCanvases\nMore\nFormatting text for surfaces\nDefining views\nUpgrading dialogs to modals\nDeep linking into Slack\nTokens\nWorkflows\nDeno Slack SDK ↗\nSlack CLI ↗\nWorkflow steps\nCustom steps dynamic options\nRun on Slack Infrastructure\nWorkflow Builder\nLegacy steps from apps\nLegacy steps from apps\nLegacy steps from apps FAQ\nWorkflow Powerups\nConfiguration views\nworkflow_step\nworkflow_step_edit\nworkflow_step_execute\nworkflow_published\nworkflow_unpublished\nworkflow_deleted\nworkflow_step_deleted\nReference\nEvents\nMethods\nObject types\nConversation objects\nConversation object overview\nChannel object\nGroup object\nIM object\nMPIM object\nEvent object\nFile object\nUser object\nUsergroup object\nScopes\nSlack functions\nSlack app manifests\nInteraction payloads\nOverview\nShortcuts payloads\nBlock actions payloads\nBlock suggestion payloads\nView interaction payloads\nTranslated content\n🇯🇵 日本語版ページ\nGov Slack\nStay updated\nDeveloper changelog\nDeveloper blog\n@SlackAPI\nResources\nGet support\nPartner with us\nSlack Fund\nFAQ\nDeveloper beta\nAPI Terms of Service\nCommunity\nCommunity Forums\nGroups and events\nSlack Engineering\nCommunity code of conduct\nSlack Platform\nSamples & templates\nDeveloper sandboxes\nSlack apps\nQuickstart: Send a message\nAuthentication\nOverview\nInstalling with OAuth\nToken rotation\nVerifying requests\nSecurity best practices\nAuthorize with Postman\nSign in with Slack\nSign in with Slack setup\nSign in with Slack links\nSign in with Slack links using Auth0\nLegacy app migration\nDifferences between classic apps and Slack apps\nMigration guide\nAI Apps\nOverview\nCustomizing Agentforce agents with custom Slack actions\nDeveloping AI apps in Slack\nAI apps best practices\nData Access API\nMessaging\nSend or schedule a message\nRetrieve a message\nEdit or delete a message\nMessage composition\nAdd interactivity\nWorking with files\nWorking with metadata\nOverview\nDesigning metadata schema\nMetadata events\nUsing incoming webhooks\nUnfurling links in messages\nUpgrading to blocks\nInteractivity\nHandling user interaction\nShortcuts\nSlash commands\nApp distribution\nDistributing Slack apps\nHosting Slack apps\nOnboarding users\nSlack Marketplace\nOverview\nSlack Marketplace review guide\nSlack Marketplace guidelines\nUsing Slack Marketplace\nSlack Marketplace checklist\nApps for Admins\nOverview\nWorkspace management\nManaging users\nManaging channels\nManaging app approvals\nManaging workflow permissions and approvals\nManging invite requests\nLegal Holds API\nOverview\nReference\nAudit Logs API\nMonitoring audit events\nMonitoring anomaly events\nEndpoints and actions\nSCIM API\nProvisioning with SCIM\nProvisioning with SCIM 2.0\nLegacy\nOverview\nLegacy authentication\nLegacy: V1 OAuth 2.0\nLegacy: OAuth Scopes\nLegacy: Sign in with Slack\nLegacy messaging\nLegacy: Messaging overview\nLegacy: interactive messages\nLegacy: Interactive field guide\nLegacy: Message buttons\nLegacy: Message menus\nLegacy: Secondary attachments\nLegacy bots\nLegacy dialogs\nLegacy custom integrations\nLegacy custom integrations migration\nLegacy custom integrations bot users\nLegacy custom integrations incoming webhooks\nLegacy custom integrations outgoing webhooks\nLegacy custom integations slash commands\nLegacy custom integrations tokens\nLegacy Steps from Apps\nLegacy Steps from Apps FAQ\nLegacy Steps from Apps migration guide\nLegacy RTM API\nPlatform concepts\nAPIs\nOverview\nWeb API\nOverview\nPagination\nRate limits\nConversations API\nCalls API\nPresence & status\nEvents API\nEvents API\nHTTP vs Socket Mode\nHTTP Request URLs\nSocket Mode\nSlack Connect\nUnderstanding Slack Connect\nUsing Slack Connect API methods\nSlack Connect API reference\nSlack Status API\nApp design\nApp manifests\nBlock Kit\nOverview\nBuilding with Block Kit\nDesigning with Block Kit\nBlock Kit Builder\nReference\nOverview\nBlocks\nBlock elements & interactive components\nComposition objects\nBlock actions payloads\nBlock suggestion payloads\nFormatting rich text\nBolt Frameworks\nOverview\nBolt for Java ↗\nBolt for JavaScript ↗\nBolt for Python ↗\nEnterprise Grid\nOverview\nSingle-workspace apps\nOrganization-ready apps\nMigrating to organization-ready apps\nTesting Enterprise Grid apps\nInvocation & interactivity\nSurfaces\nOverview\nMessages\nModals\nApp Home\nCanvases\nMore\nFormatting text for surfaces\nDefining views\nUpgrading dialogs to modals\nDeep linking into Slack\nTokens\nWorkflows\nDeno Slack SDK ↗\nSlack CLI ↗\nWorkflow steps\nCustom steps dynamic options\nRun on Slack Infrastructure\nWorkflow Builder\nLegacy steps from apps\nLegacy steps from apps\nLegacy steps from apps FAQ\nWorkflow Powerups\nConfiguration views\nworkflow_step\nworkflow_step_edit\nworkflow_step_execute\nworkflow_published\nworkflow_unpublished\nworkflow_deleted\nworkflow_step_deleted\nReference\nEvents\nMethods\nObject types\nConversation objects\nConversation object overview\nChannel object\nGroup object\nIM object\nMPIM object\nEvent object\nFile object\nUser object\nUsergroup object\nScopes\nSlack functions\nSlack app manifests\nInteraction payloads\nOverview\nShortcuts payloads\nBlock actions payloads\nBlock suggestion payloads\nView interaction payloads\nTranslated content\n🇯🇵 日本語版ページ\nGov Slack\nStay updated\nDeveloper changelog\nDeveloper blog\n@SlackAPI\nResources\nGet support\nPartner with us\nSlack Fund\nFAQ\nDeveloper beta\nAPI Terms of Service\nCommunity\nCommunity Forums\nGroups and events\nSlack Engineering\nCommunity code of conduct\nThe Slack developer docs are moving! We've been working hard at building out a new docs experience at docs.slack.dev — now in beta! You can start using the new docs today, but we'll keep the content on both sites up to date during the transition.\nLearn more\nInstalling with OAuth\n\nSlack apps are installed with a v2 OAuth 2.0 flow. We're sorry about all the \"2s\": OAuth 2.0 refers to the 2.0 version of the OAuth spec, and this is our second version of OAuth 2.0. For the rest of this guide, we'll just refer to it as \"OAuth\".\n\nFor posterity, this OAuth flow works the same as the OAuth flow for legacy Slack apps. Only a few details have changed; URL and method names have gained a v2, and the shape of the OAuth access response now puts bot access tokens first. We created a version 2 of the OAuth flow because it provides more granular Slack scopes, especially for bot users. Your app can act with its own identity, instead of acting on behalf of users — all without requesting excessive permissions that could cause installations to be rejected.\n\nHow it works: a high-level overview\n\nOAuth allows a user in any Slack workspace to install your app. At the end of the OAuth flow, your app gains an access token. Your app's access token opens the door to Slack API methods, events, and other features. During the OAuth flow, you specify which scopes your app needs. Those scopes determine exactly which doors your app can open.\n\nImplementing an OAuth flow can feel hard because there are a lot of steps, but your app really only has to worry about three steps to make OAuth work: requesting scopes, waiting for a user to give their approval, and exchanging a temporary authorization code for an access token. Redirecting a user to Slack can be done with a single link. For example:\n\n<a href=\"https://slack.com/oauth/v2/authorize?scope=incoming-webhook&client_id=33336676.569200954261\">Add to Slack</a>\n\n\nReplace the scope= with the scopes you'd like and the client_id with your app's client ID, and you've already got the redirect down. You can even turn that link into an Add to Slack button by using the generator below:\n\nLooks like you don't have any apps yet.\n\nCreate an App\nObtaining access tokens with OAuth\n\nYour app obtains an access token in three steps:\n\nRequesting scopes.\nWaiting for a user to approve your requested scopes.\nExchanging a temporary authorization code for an access token.\n\nWhy is there a third exchanging step in OAuth at all? Why doesn't Slack send your app an access token directly after the user okays your app? The reason is two-factor authentication. You have to prove both that you have the right temporary authorization code, and that you have your app's client secret.\n\nRequesting scopes\n\nWhile developing your app, you'll determine a minimum list of scopes that your app requires to work. When a user installs your app in their workspace, you'll request those scopes.\n\nTo request scopes, redirect Slack users to https://slack.com/oauth/v2/authorize. If you're developing a GovSlack app for use by public sector customers, redirect users to https://slack-gov.com/oauth/v2/authorize.\n\nA scope conflict occurs when attempting to combine Sign in with Slack (SIWS) user scopes with non-Sign in with Slack scopes in the same OAuth flow. Each set of scopes must be requested in a separate OAuth flow.\n\nInclude both your app's client ID, which is found in the App Management page, and a comma-separated list of scopes, such as: scope=incoming-webhook,commands. The full redirect URL will look something like this:\n\nhttps://slack.com/oauth/v2/authorize?scope=incoming-webhook,commands&client_id=3336676.569200954261\n\n\nThe scope list requests scopes for your app's bot user. If you have specific need for a user token (for example, so that you can act on behalf of a user), provide a user_scope parameter with requested user scopes instead of, or in addition to, the scope parameter.\n\nAlso note that each installation can result in additive scopes. For example, if a user installs your app in a workspace where you request channels:history and then installs your app again where you request channels:read, both channels:history and channels:read will be assigned to the token. There is no way to remove scopes from an existing token without revoking it entirely.\n\nWhen requesting scopes, you also need to tell Slack where to send your temporary authorization code afterward. Include a redirect_uri parameter in the URL above. The redirect_uri is where Slack will send the user back to, along with the temporary authorization code, once the user okays your app. The redirect_uri must use HTTPS. Alternatively, you can configure a Redirect URL in the App Management page under OAuth & Permissions. A Redirect URL must also use HTTPS.\n\nWhen there are multiple Redirect URL values configured, the redirect_url parameter must be sent in both the Authorize and Access steps described below, and the parameter value must be the same for both steps — otherwise, you will encounter a bad_redirect_uri error:\n\nAuthorize: You direct the user to the corresponding /oauth/v2/authorize path (this can be done with a link or button, for example). Send the redirect_uri in this step.\nRedirect: Slack redirects the user to what was specified as the redirect_uri in the previous step, and adds a verification code to that URL.\nAccess: Your server retrieves the verification code from the previous step and sends it to the oauth.v2.access API endpoint to exchange that code for an access token.  If you sent a redirect_uri field in the first step, you must send that same field with the same value in this step.\n\nIf there are multiple Redirect URL values configured, but no redirect_uri parameter is sent, the OAuth flow will use the first Redirect URL listed on the App Management page. You can use the redirect_uri parameter in your oauth/v2/authorize redirect as mentioned above and configure a Redirect URL in the App Management page. Your redirect_uri must match or be a subdirectory of a Redirect URL configured under App Management. A Redirect URL can not contain an anchor (#).\n\nREDIRECT_URL: https://example.com/path\n\nGOOD redirect_uri: https://example.com/path\nGOOD: https://example.com/path/subdir/other\nBAD:  http://example.com/bar\nBAD:  http://example.com/\nBAD:  http://example.com:8080/path\nBAD:  http://oauth.example.com:8080/path\nBAD:  http://example.org\n\nThe team parameter\n\nWhen a valid team ID is passed to team and the authenticating user is already signed in to that workspace, passing this parameter ensures the user will auth against that workspace.\n\nIf the user is not signed in yet, the user will be asked to specify a workspace to sign in to. That workspace will then be used as they complete the authorization flow, regardless of any team parameter you provided when the flow began.\n\nIf you omit the optional team parameter, the user will be allowed to choose which workspace they are authenticating against.\n\nWaiting for a user to approve your requested scopes\n\nGood news! Your app doesn't really have to do anything.\n\nPrepare for the return of a user by listening for HTTP requests at whatever Redirect URL you specified.\n\nExchanging a temporary authorization code for an access token\n\nIf all goes well, a user goes through the Slack app installation and okays your app with all the scopes it requests. Then, Slack redirects the user back to your specified Redirect URL.\n\nParse the HTTP request that lands at your Redirect URL for a code field. That's your temporary authorization code, which expires after ten minutes. Check the state parameter if you sent one along with your initial user redirect. If it doesn't match what you sent, consider the authorization a forgery.\n\nNow, you just need to exchange the code for an access token. You'll do this by calling the oauth.v2.access method as follows:\n\ncurl -F code=1234 -F client_id=3336676.569200954261 -F client_secret=ABCDEFGH https://slack.com/api/oauth.v2.access\n\n\nOnce you complete your access call, Slack sends you an HTTP request response containing an access token. It looks something like this:\n\n{\n    \"ok\": true,\n    \"access_token\": \"token\",\n    \"token_type\": \"bot\",\n    \"scope\": \"commands,incoming-webhook\",\n    \"bot_user_id\": \"U0KRQLJ9H\",\n    \"app_id\": \"A0KRD7HC3\",\n    \"team\": {\n        \"name\": \"Slack Pickleball Team\",\n        \"id\": \"T9TK3CUKW\"\n    },\n    \"enterprise\": {\n        \"name\": \"slack-pickleball\",\n        \"id\": \"E12345678\"\n    },\n    \"authed_user\": {\n        \"id\": \"U1234\",\n        \"scope\": \"chat:write\",\n        \"access_token\": \"xoxp-1234\",\n        \"token_type\": \"user\"\n    }\n}\n\n\nIf you requested scopes for a user token, you'll find them with a user access token under the authed_user property.\n\nOne more suggestion: show the user a nice message once they are redirected and you successfully gain an access token — or, if there's been an error, report that error to the user. The reason the user is redirected back to your app at the end of OAuth is for transparency purposes: the user deserves to know the end of the story, whether your app was installed successfully or not.\n\nMore about tokens\nUsing tokens\n\nThe best way to communicate your access tokens — also known as bearer tokens — to Slack is by presenting them in a request's Authorization HTTP header where the full value, including \"Bearer\", is case-sensitive. This approach is required when using application/json with a write method.\n\nGET /api/conversations.list?limit=50\nAuthorization: Bearer xoxb-1234-abcdefgh\n\n\nAlternatively, you may send the token as a POST body attribute of the application/x-www-form-urlencoded variety.\n\nPOST body:\n\nPOST /api/conversations.list\nContent-type: application/x-www-form-urlencoded\ntoken=xoxb-1234-abcdefgh&limit=50\n\nRevoking tokens\n\nOAuth tokens do not expire. If they are no longer needed, they can be revoked. Revocation of an OAuth token happens if a workspace owner fully uninstalls the app, a user individually removes their configurations, or the account of the user who initially authenticated the Slack app is deactivated.\n\nAPI access tokens are revoked via the auth.revoke method. After that happens:\n\nThe bot token no longer works.\nThe bot user is removed from the workspace.\nSlash commands associated with the bot token will be removed from the workspace if no user tokens for the same app exist and carry the commands scope.\nIncoming webhooks that were installed and associated with the bot token will be removed.\nIf no user tokens for the same app exist, the app will appear to be uninstalled from the workspace.\n\nAdditionally, for Slack apps using granular permissions, you can exchange your access token for a refresh token and an expiring access token with token rotation.\n\nStoring tokens securely\n\nStore your application's credentials and user tokens with care. Restrict Web API access to only IP addresses you trust by allowlisting specific IP addresses. Read up on best practices for security.\n\nCreating a classic app\n\nDiscontinuing new classic Slack app creation\n\n\nYou won't be able to create new classic apps or legacy custom integration bot users anymore after June 4, 2024. Learn how this may impact you and your team.\n\nErrors\n\nBelow are some errors you may encounter and reasons for encountering them:\n\nbad_redirect_uri: Occurs when there are multiple redirect_url parameter values configured and they do not match.\ninvalid_scope: Occurs if requesting a non-existent scope or requesting a set of scopes that are in conflict with each other (e.g. SIWS user scopes cannot be combined with non-SIWS user scopes).\ninvalid_team_for_non_distributed_app: Occurs when attempting to install/authorize an undistributed Slack API app on a team where the app was not created.\nscope_not_allowed_on_enterprise: Occurs when attempting to install an app on an Enterprise Grid org containing scopes that are not org-compatible.\nunapproved_scope: Occurs if attempting to install a published app for which the requested scopes aren't approved either because they're still in review for that app, or they weren't yet submitted for review by the app developer.\nRecommended reading\nInstallation & permissions\nOn this page\nHow it works: a high-level overview\nObtaining access tokens with OAuth\nRequesting scopes\nThe team parameter\nWaiting for a user to approve your requested scopes\nExchanging a temporary authorization code for an access token\nMore about tokens\nUsing tokens\nRevoking tokens\nStoring tokens securely\nCreating a classic app\nErrors\nBuild something social for your team on Slack\n🏃‍♀️ Customize our Running Buddies tutorial for your favorite activities\nStatusPolicyTermsYour Privacy ChoicesCookie Preferences\n\nSubscribe to our developer changelog\n\nConnect with our platform community\n\nNeed help? Contact developer support",
  "updatedAt": "2025-05-10T19:34:06.435Z"
}
